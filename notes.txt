https://github.com/facebook/create-react-app

>> Create-React-App is a command line interface tool that allows us to quickly
   create and run React Applications with no configuration.

>> What that means is we simply run a command and an entire React project is 
   created for us.

* What is NPX ? 
-> NPX is an npm package runner which gets installed when you install Node.
   And that is how we're directly able to run, create React App without 
   having to install it. NPX takes care of that for us.

* package.json 
-> This files contain the dependencies and the scripts required for the project.
   
* package-lock.json 
-> Based on whether we have just `npm` or `yarn` as a package manager, we're gonna see yarn-lock or package-lock files.
-> They simply ensure consistent installation of your dependencies.

* node_modules
-> The folder in which all the depencencies are installed. Generated when we run `npm install` or `create-react-app`
   command.

What is ReactDOM.render( <App />, document.getElementById('root) ) in index.js ?
> Here, we specify the root component which is <App /> and the DOM element which'll 
  be controlled by React. The DOM element in our case is an element with the ID = root 
  which is defined in index.html. We call this div element as the Root DOM node because 
  everything inside it will be controlled by React.

> For the Hello World component (see video 2), the App component is rendered inside the 
  root DOM node.

> ReactDOM renders the App component on to the Root DOM node.

> There's one component to contain every other component. The containing component is the 
  root component and is usually named as App component in your application.

* Functional Component & Class Component 
-> What is the advantage of using one over the other and when 
   exactly should you use a particular component type ?

-> Earlier, Functional components were stateless. But, Hooks are a new 
   feature proposal that lets you use state and other React features 
   without writing a class.

Before jumping in to hooks - few things to consider 
  - learn how to use state, lifecycle methods and `this` binding in Class components.

* JSX - JavaScript XML - Extension to the JavaScript language syntax.
- Write XML-like code for elements and components.
- JSX tags have a tag name, attributes, and children.
- JSX ultimately transpiles to pure JavaScript which is understood by the browsers.

- Each JSX element is just syntactic sugar for calling React.CreateElement

- Props which is the short form for properties is the optional input that your component 
  can accept. It also allows the component to be dynamic.

- Props is just an object that contains the attributes and their values which have been 
  passed from the parent component. They are used to make the component re-usable.

- Unlike the functional component where we specify the props parameter ; In a class 
  component the properties are available through `this.props` which is reserved in class components.

- Understand `props.children` from here --> `https://codeburst.io/a-quick-intro-to-reacts-props-children-cb3d2fce4891`

- Props are immutable.
- Now, we might have a question, if props are immutable how do we maintain component data that might change 
  over time ?

- The answer to this is `State`.

- props vs state 

  : Props get passed to the component while state is managed within the component.
  
  : Because a parent usually passes down the props to the child component, 
    props are immutable. The parent owns the props and cannot be changed 
    by the children.

  : State on the other hand is managed within the component and hence the 
    component has fully control to change the state.

  : In functional components, props can be accessed using the props parameter
    and in class components props can be accessed using this.props.

  : State on the other hand can be accessed using the useState hook in functional 
    components & this.state in class components.

  : A state is nothing but an object that is privately maintained inside a component.
  : A state can influence what is rendered in the browser.

- When you've to change the state of a component, we need to use the `setState` method.
- Calls made to `setState` are Asynchronous.

- Always make use of setState and never modify the state directly.
- If you have a code that must be executed after the state has been updated, 
  place that code in the callback function which is the second argument to the 
  setState method.


For below 2 points, watch video 11 from 10:20 - 11:35 min and read again.
 - React may group multiple `setState` calls into a single update for better performance.
 - Therefore whenever you have to update the state based on the previous state, we need to pass 
   function as an argument to setState method instead of passing in an object.

Destructuring :- 
 - It is an ES6 feature that makes it possible to unpack values from arrays 
   or properties from objects into distinct variables.

 - In React, destructuring props & state improves code readibility.
 - Destructuring in a functional based component happens in 2 ways - first in the 
   functional parameter & second way is to destructure it in the function body.

 - 1st WAY --> const Greet = ({name, heroName}) => { 
    return (
    <div>
    <h1>Hello {name} a.k.a {heroName}</h1> 
    </div>
    )
  }

-  2nd WAY --> const Greet = props => { 
    const {name, heroName} = props
    return (
    <div>
    <h1>Hello {name} a.k.a {heroName}</h1> 
    </div>
)
}

In class components, we generally tend to destructure props or state in the 
render method.

For ex, : const {name, heroName} = this.props

We are simply extracting the necessary props. Our props object could contain 10
different props but you can destructure only the ones you wish to use in your 
component.

Similarly, we might also have a number of state properties. Can be destructured in the 
similar way as above.

Understand Constructors with React Components --> https://www.knowledgehut.com/blog/web-development/understanding-constructors-with-react-components

Binding Event Handlers :- `https://www.geeksforgeeks.org/reactjs-binding-event-handlers/`

1st Option -> Binding in the render method. 
              Use the bind keyword and bind the handler in the render method.
           : Although this option works perfectly fine. Every update to the 
             state will cause the component to rerender. This in-turn will
             generate a brand new event handler on every render. 

           : Although the impact on performance is not severe in small applications.
             It could be troublesome in large applications and components that contain 
             nested children components.

2nd Option -> To use arrow functions in the render method.

           : This approach is simply calling the event handler in the arrow function body.
           : Similar to the first approach, this also has performance implications in some 
             scenarios.

3rd Option -> This approach deals with binding the event handler in the constructor 
              (i.e class constructor )
              as opposed to binding in the render method.

           : Because the binding happens once in the constructor, this approach is better 
             compared to binding in the render method.

4th Option -> To use an arrow function as a class property.

super(props) will call the base class constructor. In our component, we have access to this.props only 
after we have initially called super passing in the props as an argument.


: Till now, we've seen how a parent component can pass down props to its children components.
: Any data in the parent component, when passed as props is available in the children components.
  Now, what if a child component wanted to communicate with the parent component ?
  - We still use props for this, but this time we pass in a reference to a method as props to the 
    child component.

: In nutshell, we wish to have a child component calling a parent component's method.
  Can be achieved using props. The only difference this time is we pass the method 
  itself as a prop to the child component. We use the attribute `greetHandler` for that.

  See files --> ParentComponent.js & ChildComponent.js 
  : There in, we've successfully called a method in the parent component from a button 
    in the child component by passing the method as props to the child component.

  How to pass a parameter when calling the parent method from the child component ?
  : Can use an arrow function in the return statement. Arrow function syntax is the 
    simplest way to pass parameters from the child component to the parent component.
    
  : Again, refer the files --> ParentComponent.js & ChildComponent.js where in we have 
    successfully passed a parameter from the child to the parent.

4 approaches for conditional rendering :-
  - if/else, element variables, ternary conditional operator, short circuit operator.

Element Variables - In this approach, we use JavaScript variables to store elements. This 
                    will also help us conditionally render the entire component or only a 
                    part of the component as well.

TIP - It's always good to refactor the JSX into a separate component.


 - Why do we need a KEY prop ?
 - Keys help React identify which items in a list have changed or added or removed and plays
   a crucial role in handling UI updates efficiently.

The key prop is a special attribute we need to include when creating lists of elements.
Keys give the elements a stable identity.
An important point to keep in mind about key prop is that they are not accessible in the
child components.

Key prop is something React needs to render the list efficiently. If we're trying to pass 
down a value to be used in the child component, we must pass it as a different prop. KEY 
prop is reserved.

Styling React Components - 4 approaches (3 to be discussed in the course)

1. CSS StyleSheets --> files to look in -> Stylesheet.js & myStyles.css
2. Inline styling  --> Create an object and apply it to the style attribute -> check Inline.js file 
3. CSS Modules  --> files to look in --> appStyles.css, appStyles.modules.css
4. CSS in JS Libraries

In regular HTML, form elements like input, textarea & so on are responsible on their own to handle 
the user input and update their respective values, but what we want is for React to control the 
form elements instead. Such form elements whose value is controlled by React is called a
controlled component.

When we assign a handler to the onChange event, the event itself is passed as a parameter to the 
handler. (Check `handleUsernameChange` function in Form.js file)

When we dismiss the alert , the page refreshes and the filled in data is lost. To avoid this, we 
simply add an `event.preventDefault` call. This will prevent default behaviour of form submission.

As a part of code cleanup, it's always good to destructure the state properties in the render method.

When we create a React Component, the component goes through several stages in its lifecycle. React provides 
us with built in methods that we can override at particular stages in the life cycle.

Lifecycle method available for a class component :- Those methods can be classified in 4 phases :- 
1) Mounting  - These methods are called when an instance of a component is being created and inserted into the DOM.
2) Updating  - These methods are called when a component is being re-rendered as a result of changes to either its props or state.
3) Unmounting - These lifecycle method is called when a component is being removed from the DOM.
4) Error Handling - These methods are called when there is an error during rendering in a lifecycle method or in the constructor of 
                    any child component.
 
1) Mounting lifecycle methods (Check LifeCycleA.js & LifeCycleB.js files to understand these things)
   - constructor (props) -- A special function that'll get called whenever a new component is created.
   - static getDerivedStateFromProps( props, state) -- When the state of the component depends on changes in props over time. We can use this method to set the state.
   - render() -- We simply read this.props and this.state and return JSX which describes the UI.
   - componentDidMount() -- This method is called only once in the whole lifecycle of a given component and it is invoked immediately after a component and all its
                            children components have been rendered to the DOM. We can use this method to interact with the DOM or perform any Ajax calls to load the data.
                            It is a good place to perform initialization that requires DOM nodes and also load data by making network requests.

2) Updating lifecycle methods 
   - static getDerivedStateFromProps(props, state) -- Receives state and props as a parameter and has to return either null or an object that represents the updated state 
                                                      component. Called every time a component is re-rendered. One of the more rarely used methods in the updating phase.
   
   - shouldComponentUpdate(nextProps, nextState) -- This method receives the updated props and state and the purpose of this method is it dictates if at all the component 
                                                    should re-render or not. By default, all class components will re-render whenever the props they receive or their state 
                                                    changes. This method can prevent that default behaviour by returning `False`. What we can do in this method is compare 
                                                    existing props and state values with the next props and state values and return `True` or `False` to let React know 
                                                    whether the component should update or not. This method is basically for performance optimization.
   
   - render()
   - getSnapshotBeforeUpdate(prevProps, prevState) -- Accepts prevProps and prevState as its parameters and is called right before the changes from the Virtual DOM are to be 
                                                      reflected in the DOM. We would use this method to capture some information from the DOM. For example, we can read the 
                                                      user's scroll position and after the update, maintain that scroll position by performing some calculations. This method 
                                                      will either return null or return a value. The returned value be passed as the third parameter to the next method in the 
                                                      list (See below.) In nutshell, this method is used to read the current DOM state and returns a value or NULL.

   - componentDidUpdate(prevProps, prevState, snapshot) --  This method is called after the render is finished in the re-render cycles. This means we can be sure that the
                                                            component and all its sub-components have properly rendered itself after the update. Accepts 3 parameters - the 
                                                            snapshot one is the value returned from the `getSnapshotBeforeUpdate` method. This method is guaranteed to be 
                                                            called only once in each re-render cycle. We can use these method to perform AJAX calls. Before making the call, 
                                                            we need to compare the previous props with the new props and then decide whether to make the AJAX call or not.
                                                            If we don't compare we might make unwanted requests which is not a good thing.  
                                                            

NOTE :- `https://stackoverflow.com/questions/50819162/why-is-my-function-being-called-twice-in-react`

3) Unmounting phase method
   - componentWillUnMount -- This method is immediately invoked before a component is unmounted and destroyed.
                             With this method, we can perform any cleanup tasks like cancelling any network 
                             requests, cancelling any subscriptions and also invalidating timers from setTimeout
                             & setInterval.

4) Error handling phase methods
   - static getDerivedStateFromError(error)
   - componentDidCatch(error, info)

     - These two methods are called when there is an error either during rendering, in a lifecycle method, or in 
       the constructor of any child component.


React Fragments :-

- Fragments basically lets you group a list of children elements without adding extra nodes to the DOM.
- FragmentDemo.js --> If we add <div> to enclose h1 & p, there will be an extra div tag added after the app.js div.
                      To remove that extra node being added, we use `React.Fragment` instead. 

So far, we've creating Class Components by extending the `Component` class from React. (for ex - class App extends Component)
There is 1 more class from which we can extend. And that is `PureComponent`.

What is the difference between the `Component` class and the `PureComponent` class ?
> Look at the files -- ParentComp.js, PureComp.js, RegComp.js -- What we're concerned about in those examples though is when 
  the render method is called in each of the components.

  All 3 components are like this :- 
   - class ParentComp extends Component
   - class RegComp extends Component
   - class PureComp extends PureComponent

> After adding necessary console.log statements and rendering the ParentComp, we observe --> 
  - Initially we've Parent Render, Regular Component render & Pure component render.
  - But after that, every 2 seconds the setState method is called which will re-render the parent component.
    And if the parent component re-renders, the child components will also re-render unless we return `False` from 
    shouldComponentUpdate.
  - So, ideally we should see the render from both regular & pure components being logged. However, that's not the case.
    EVERY 2 seconds, ParentComp & the RegComp are re-rendered but the PureComp is never re-rendered.   

  THIS IS THE DIFFERENCE BETWEEN THE Regular Component Class & the Pure Component Class. 

   - A regular component does not implement the `shouldComponentUpdate` method. It always returns `True` by default.
   - A pure component on the other hand implements `shouldComponentUpdate` with a shallow prop and state comparision. (%%%^)

   What exactly is Shallow props and state comparision ?
   > We can get more idea of it with respect to Primitive & Complex types.

   > For two primitive types a & b like numbers,
     strings & boolean. a (SC) b (i.e read as a shallowComparision b) returns true if a & b have the same value and are of the same type. 
     For example, if `a` and `b` are both strings with the value `Arvish`, the shallow comparision returns True.

   > For complex types like objects & arrays, a (SC) b returns True if a & b reference the exact same object.
     Consider the examples below to understand it.

     var a = [1,2,3];
     var b = [1,2,3];
     var c = a;

     var ab_eq = (a === b); // false because even though the items in both the arrays are the same, those 2 arrays do not reference the same object.
     var ac_eq = (a === c); // true because they point to the same object.

     Same is the case with objects as well.

     var a = { x:1, y:2 };
     var b = { x:1, y:2 };
     var c = a;

     var ab_eq = (a === b); // false 
     var ac_eq = (a === c); // true 

     Continuing from (%%%^) :-
     >  It does a shallow comparision of previous state with current state & previous props with current props.
        And ONLY WHEN the shallow comparision indicates there is a difference , THE COMPONENT WILL RE-RENDER.

     In our example, we're dealing with primitive types & props comparision. We're sending a prop which is of type
     string and has a value of `Arvish`. Every 2 seconds the pure component sees that the previousProp value of `Arvish`
     is no different from the currentProp value of `Arvish` AND HENCE DOES NOT RE-RENDER.

     And because a regular component does not implement this check, IT'LL ALWAYS RE-RENDER. 

     What we've seen is a shallow comparision of Props, but it's pretty much the same for state comparision as well.

     We shall now change the ParentComponent to extend PureComponent instead of the RegularComponent class.
     Like this --> class ParentComp extends PureComponent

     If we now take a look at the browser, we'll see that there is the initial rendering of all the components :- Parent, Regular & Pure.
     This time, two seconds later there's no re-render.

     The ParentComp checks previous state with current state and sees that THERE'S NO DIFFERENCE and hence THERE'S NO RE-RENDER.
     But, what we should keep in mind is if the Parent doesn't re-render, the children also will never re-render and that's why we didn't 
     see any statement logs in the two second intervals.

     So, now we can answer WHY to use PureComponents ? 
     > Pure components by preventing unnecessary renders can give you a performance boost in certain scenarios.
     > For example, let's say you're rendering a list of 50 items. By not re-rendering them when it is not required, 
       they're going to have a good performance boost.

       A KEY POINT to keep in mind is that you should not mutate objects or arrays in props or state.
       For example, if you need to add a new item to the list, we shouldn't mutate it by pushing the item 
       into the list. The reference to the array never changes and because PureComponent's only check for that,
       the component will not re-render even if there's a difference. ALWAYS RETURN A NEW OBJECT OR ARRAY WHEN 
       DEALING WITH PURE COMPONENTS.

       It is also a good idea to ensure that all the children components are also pure to avoid unexpected behaviour.
       When using PureComponents, never mutate the state. Always return a new object that reflects the new state.


Pure Components only re-render the class components when there is a difference in the shallow comparision of props and 
state. This of-course results in a performance improvement. Pure components THOUGH ONLY WORK WITH CLASS BASED COMPONENTS.

It would be nice if we could achieve the same in functional components as well. That is where React.MEMO comes into the picture.
What PureComponents is to class based components, MEMO is to functional components.

REFS - They make it possible to access DOM nodes directly within react. They're used to access & modify the DOM elements in the 
       React Application. It creates a reference to the elements and uses it to modify them.

       Refs are a function provided by React to access the DOM element and the React elements created in components. They are used 
       in cases where we want to change the value of a child component, without making use of props and state.

 Ex  - We might want to achieve something like this --> As soon as the page loads, we a particular input field to be focused.

Second possible use case for using refs would be to fetch the input value.
One way to create access refs is using `React.createRef()`. React also supports a second way to set refs which is called as callback refs.
Check file - RefsDemo.js to learn how to add Refs to normal HTML element like the input element.

It is also possible to add a ref to a class component. (If at all we need a ref to a child component from a parent component)
Check Files - Input.js & FocusInput.js

(video 30) => Forwarding Refs - It is a technique for automatically passing a ref through a component to one of its children. 
Check Files - FRInput.js & FRParentInput.js

What we want to achieve is when we click on the button in the parent component, the input in the child component should 
receive focus. Unlike the last video (i.e video no 29 -- files = Input.js & FocusInput.js) where the ref was pointing to 
the class component, in this video ( video no 30 ), we'll use the forwarding ref technique to allow the parent component
to directly reference the native input element. (i.e from Child to Parent)

Difference between video 29 & video 30 :- 
- For anyone who is confused between the previous video and this, let me break it down for you.
'ref 'in React  is basically used to access HTML nodes, in the previous we learned that refs can also be used to access components in React, in a similar way we did the HTML element. 
In this video we referenced the Child Component as well, but then we used React.forwardRef() to forward the reference from the child component to the input element inside the component.

Thus we were directly able to access the focus() method of <input> tag directly in our Parent Component via this.inputRef.current.focus(). if we would'nt have forwarded the ref we 
could'nt have accessed it directly via  the current object.

REMEMBER - Every functional component receives props as it's parameter. 
ALSO - When a component is passed as a parameter to the createRef method, 
       it receives the ref attribute as its second parameter (check file FRInput.js)
       That ref parameter will point to the value of the ref attribute from the 
       Parent Component. 

In FRParentInput.js, the ref is being forwarded from the parent component to the 
native input element.

React Portals :-
- They provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent 
  component.

- So far, we've had one DOM element in our HTML that we were mounting the React application into. Check
  public/index.html, we can see <div id="root"></div> . In index.js, we use ReactDom.render and mount our 
  app component on to the root element. 

- When we look at the browser, In the DOM tree every single React component in our application falls under 
  the root element i.e the div element with the ID = root.

- What React portals provide is the ability to BREAK OUT of this DOM tree. So, we can render a component onto a 
  DOM node that is not under this root element.

- In our React application, even though all the components are children to the app component and the app 
  component is mounted onto the Root DOM node, it is possible to break away from that and mount on any DOM 
  node that we wish to using react portals.


The error handling phase includes two lifecycle methods.
 - static getDerivedStateFromError(error)
 - componentDidCatch(error, info)

- The first parameter to createPortal method can be any element that React can render. It can be numbers, 
  strings, JSX or even components.


Runtime errors during rendering could put our application in a broken state. React basically unmounts the 
whole react component tree. What would be great is if we could catch the errors anywhere in the component 
tree and display a fallback UI. This is where error boundaries take the spotlight.

What exactly is the error boundary ?
> A class component that implements either one or both of the lifecycle methods `getDerivedStateFromError`
  or `componentDidCatch` becomes an error boundary.

  getDerivedStateFromError - Used to render a fallback UI after an error is thrown.
  componentDidCatch        - Used to log the error information.

  Error boundaries are React Components that catch JavaScript error in their child component tree, log those 
  errors and display a fall-back UI.

  The placement of the error boundary also matters as it controls if the entire app should have the fall-back 
  UI or just the component causing the problem.

Error boundaries catch errors during rendering in lifecycle methods and in the constructors of the whole tree 
below them. However, they do not catch errors inside event handlers. If we have an onClick handler and wish to 
catch and error, we just need to use the regular try-catch statements and not error boundaries.

Higher Order Components :-

 > In the files - clickCounter & HoverCounter, we have the counter functionality which could have been re-used 
   but instead has been duplicated. So if 10 different components needed a counter functionality, we'd be writing 
   the exact same code over & over again. 

 > The question now is how can we re-use this code ? - The immediate thought is to lift this state to the parent 
   component & pass down the handler as a prop. So, it means defining the counter functionality in the app component
   and provide the state & the handler as props to clickCounter & HoverCounter

 > This would definitely work in our scenario where we have the counter components as children of the same parent.
   But if the counter components are scattered in the React Component tree, lifting the state would not be a proper 
   solution.

 > There is a need to share common functionality between components without repeating code and that is where the
   concept of higher-order components comes into picture.

 > A higher order component is a pattern where a function takes a component as an argument and returns a new component.
   Something like this - const newComponent = higherOrderComponent( originalComponent )

   Typically, an HOC adds additional data or functionality to the original component so the new component can also be 
   referred to as enhanced component.

> In video 34, until 5:32 min - Our HOC (withCounter.js) injects a `name` prop to any component required. For our counter 
  example though, that's not really what we want. We want the counter functionality to be shared amongst the components.

  After making the required changes (till 6:38 min), in HOC we need to pass down the state and the incrementCount method as 
  props so that the original component can make use of that functionality. The HOC pattern is used to share common functionality 
  between components without having to repeat the code.

  As we've learnt till now that the HOC pattern is used to share common functionality between components without having to repeat 
  the code. There's an another pattern for sharing code between react components which is the `render props` pattern.

> Video 37 => At 3:48 min => In React, it is possible to use a prop whose value is a function to control what is actually rendered 
                             by a component. THIS IS PRETTY MUCH WHAT THE RENDER PROPS PATTERN IS BASED ON !

  What is Render Props ? 
  > The term `render prop` refers to a technique for sharing code between React Components using a prop whose value is a function. 


Passing down props manually at every level becomes a problem for certain types of props such as language preference, UI theme & 
authenticated user which are pretty much required by many components in our application. What would be nice is if we could directly 
send data to the required component without having to manually drill down the props through evety level of the component tree. 
THIS IS WHERE `CONTEXT` comes into picture.

> Context provides a way to pass data through the component tree without having to pass props down manually at every level.
> 3 steps to follow in here 
  (i)   Create the Context
  (ii)  Provide a Context value 
  (iii) Consume the Context value in the necessary components

> Every Context object created using the createContext method comes with a provider and a consumer React component.

Two more points about the Context API: 
 - We can set a default value to our context. It is set while creating the context. Comment out the Provider component to see 
   the default value. Default value will only be used when a component does not have a matching provider above it in the 
   component tree.

 - We've used the consumer component to consume the context value. There's another way to do that i.e the context type property
   on a class.

 - ContextType syntax looks much simpler than consumer component syntax. There are however two limitations with context type.
    - 1) It only works with class components.
    - 2) Second limitation is you can only subscribe to a single context using context type.

   Many a times in our application, we need to read more than one context in which scenario the consumer component is the way
   to go.

 - When we change state (with `setState`), the component re-renders.

What are Hooks ?
> Hooks are a new feature addition in React version 16.8 which allow us to use React features without having to write a class.