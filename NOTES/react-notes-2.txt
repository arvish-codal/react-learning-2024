*************************************************
Video 69 - useCallback Hook - WHAT, WHY & HOW ?
*************************************************


Initial structure - App.js has one component in it -- ParentComponent

`ParentComponent` is simply a container for other components. (such as Button, Count & Title)
The JSX of ParentComponent - Contains 5 components in total of which two are re-used with 
                             different props.

The children prop in Button component => `props.children` refers to the 'Increment Age' text in the 
parent component.

In nutshell, ParentComponent has got the following components - 
   - a title component which simply renders a <h2> tag.
   - a component to display a person's age & a component to increment the person's age.
   - a component to display a person's salary & a component to increment the person's salary.


WE MIGHT BE THINKING WHY do we need to break this down into 5 components ? Could we not just 
have all the JSX in the parent component itself and make it simpler. 
> We definitely could do that but we've written the code in this particular way because we need 
  to understand about performance optimization & off-course the `useCallback` Hook.

> PERFORMANCE OPTIMIZATION - Here, if we check the logs we see 5 log statements (1 from each component.)

  If we clear the console & increment age, we see that every component is re-rendered even though we only 
  clicked the increment age. Ideally the count component related to age and the button component for 
  increment age should re-render. The other three components don't have to re-render. 
  Similar is the case with salary.

  This isn't really a problem with few components that have simple logic. But, we should consider a scenario
  where there are lots of components & updating a single component is going to re-render all the 20 or 30 or
  even 50 components. WE WOULD THEN START SEEING PERFORMANCE ISSUES.

  To improve performance, we have to restrict re-renders to only components that need to re-render.
  
  So, how do we optimize this -> The answer is React.Memo , It is a HOC that'll prevent a functional component 
  from being re-rendered if it's props or state do not change.

  --- NOTE - React.Memo HAS NOTHING TO DO WITH HOOKS. It has been a feature since React Version 16.6 ---

  To use memo, what we can do is when exporting the components, wrap them with React.Memo 
  We add that in Button, Count & Title components.

  >> If we click increment age now, we'll see fewer logs. But it is still not right. When we increment age, 
     the button to increment salary is still being re-rendered. If we click on increment salary, VICE-VERSA.

  >> WHY IS THIS HAPPENING ?
     We see the title component. It has no props or state of its own and hence does not re-render when we
     increment the age or salary.

     Next, we've count & button related to age. Count accepts age as a prop & button accepts incrementAge as 
     a prop which is dependent on age. (i.e the setAge setter function is dependent on age.). So, when the age 
     increments, both the components i.e Count & Button related to age should be re-rendered. BUT, what we see
     is that the increment salary button also re-renders. The count component for salary though does not 
     re-render.

     THIS IS BECAUSE a new `incrementSalary` function is created each time the parent component re-renders.
     
     ``` IMP ```
     When dealing with functions, we always have to consider reference equality. Even though the two functions 
     have the exact same behaviour, it does not mean they're equal to each other. Therefore, the function before 
     the re-render is different to the function after the re-render and since the function is a prop, React.memo
     sees that the prop has changed and will not prevent the re-render.
     ``` IMP ```

     And above is the same case when we increment salary as well. There is a new `incrementAge` function created
     which will cause the `incrementAge` button to re-render.

     SO, HOW DO WE FIX THIS ? HOW DO WE TELL REACT THAT THERE IS NO NEED TO CREATE A NEW INCREMENT SALARY FUNCTION
     WHEN WE UPDATE THE AGE.

     >>> THE ANSWER IS `USECALLBACK` HOOK 
         -------------------------------- 

What is useCallback hook ?
> It is a hook that'll return a memoized version of the callback function that only changes if one of the dependencies 
  has changed.

 > If we relate this to our example, it means that the useCallback hook will cache the incrementSalary function and return
   that if salary is not incremented.

   If the salary does increment, i.e if the dependency has changed, ONLY THEN a new function will be returned.

 > New function is created each rerender, and to solve that function should be memorized using a callback hook

Why do we need useCallback ?
> It is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders.

> Let's break it down - 
  -> The first part is that it is useful when passing callbacks, i.e functions like incrementAge & incrementSalary.
  -> The second part says to optimized child components. We currently have 3 child components that are optimized with React.memo (i.e 
     Button, Count & Title) to prevent unnecessary re-renders.

  REFERENCE EQUALITY - It is nothing but checking if the functions are equal which is required for our example.

As it turns out, there is another hook which is also concerned with performance optimization and that is the `useMemo` hook.
In real world applications though, we might sometimes come across logic that takes considerable amount of time for execution.
i.e a function that isn't good with performance.

Video 70 - From 6:45 min :-
-----------------------------
When we click on the other button & still there is a delay with the UI updates. When we click that button, after a second or two the 
counterTwo increments. THIS IS STRANGE though. Why is counterTwo slow when the isEven has to be called with counterOne only & not counterTwo.

ANSWER - That is because every time the state is updated, the component re-renders. And when the component re-renders, `isEven` function is called 
         again. The function is slow & hence even when we update counterTwo, the UI update is slow.

         What we need is a way to tell React not to recalculate certain values when unnecessary ; especially the ones which take a long time to
         compute. 

         In our example, we need to tell React not to calculate whether `counterOne` is odd or even when we are changing `counterTwo` values.


This is where the `useMemo` hook comes into picture. `useMemo` is a hook that'll only recompute the cached value when one of the dependencies has been changed. 
This optimisation heads to avoid expensive calculations on every render.

The first argument to `useMemo` is the function whose return value needs to be cached.
As a second parameter, we need to specify the depencencies. Our function depends on the value of counterOne i.e whenever counterOne changes, 
we are telling React to recompute the value and not use the cached value.

Also, in code change isEven() to isEven.  `isEven` is not going to be a function call because it now stores a value.



DIFFERENCE BETWEEN USECALLBACK & USEMEMO 
>> The difference is that `useCallback` caches the provided function instance itself whereas `useMemo` invokes the provided function & caches 
   its result. 

   If we need to cache a function                        ==> useCallback
   If we need to cache the result of an invoked function ==> useMemo


So far, we've had a look at several Hooks.
== > useState, useEffect, useContext, useReducer, useCallBack, useMemo & useRef.

These hooks are all provided by the react library and we've seen that these hooks are pretty much functions that can be invoked within our
components. IT IS POSSIBLE to build our own Hooks by extracting component logic into re-usable functions. In simpler terms, it is possible 
for anyone to create their own custom hook. 

> A custom Hook is basically a JavaScript function whose name starts with "use". A custom hook can also call other hooks if required.

Why would we want custom hooks ? 
> To share logic between two or more components. Custom hooks is a simpler alternative to HOC & render props pattern.