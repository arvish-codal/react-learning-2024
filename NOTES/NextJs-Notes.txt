What is Next.js ?
> It is a React Framework for building web applications.

When building applications with React alone, it's not feasible to create a fully featured application 
ready for production. 

React is a library for building User interfaces (UI), responsible only for the view layer of an application.
As a developer, we need to make decisions about other features such as routing, data fetching and more.

Next.Js on the other hand is a React Framework. It uses React for building user interfaces but also provides
additional features that enable you to build production-ready applications.

These features include routing, optimized rendering, data fetching, bundling, compiling and more. We don't need 
to install additional packages as Next.js provides everything we need.

However, NextJs being a framework has opinions and conventions that should be followed to implement these features.


To create a new NextJS project, we need to run the following command :- 
  - npx create-next-app@latest

The `.next` folder --> This folder is generated when we run either the dev or build scripts. (i.e for example - npm run dev)
It is from this folder that our NextJS application is served.

The `node_modules` folder --> This is where all the dependencies of our project are installed.

The `public` folder --> This folder holds all the static assets to be served such as images and SVG's.

Inside the `src` folder, we've one folder called app which is the newly introduced app router.

There are some scripts present in the `package.json` :- 
 
 {
    "scripts": {
       "dev": "next dev",
       "build": "next build",
       "start": "next start",
       "lint": "next lint" 
    }
 }

 These scripts refer to the different stages of developing an application :-
  - dev: runs `next dev` to start Next.js in development mode.
  - build: runs `next build` to build the application for production usage.
  - start: runs `next start` to start a Next.js production server.
  - lint: runs `next lint` to set up Next.js' built-in ESLint configuration.


In the context of `Hello-World` project, 
> When we run the command `npm run dev`, the execution is transferred to `layout.tsx`, 
  The `RootLayout` Component is rendered.

> When we navigate to localhost:3000, the children prop will always refer to the component defined in `page.tsx` 
  in the `app` folder. That component is the `Home` component which is then rendered in the browser.

  React Server Components is a new architecture introduced by the React team in version 18.
  The architecture introduces a new way of creating React Components - splitting them into two types :-
   - Server Components & Client Components

> Server Components :- 
 - In Next.js, all components are Server components by default. They have the ability to run tasks like reading files or
   fetching data from a database. 
 - However, they don't have the ability to use Hooks or handle user interactions.

> Client Compontoents :-

 - To create a Client component, it's necessary to add "use client" at the top of the component file. Client components are the
   traditional React components.

NextJS has a file-system based routing mechanism where the URL paths accessible in the browser are defined by files & folders within 
our codebase.

Some points to note :- 
 - The `page.tsx` file within the app folder corresponds to the domain root and page.tsx files within the subfolders are associated
   with routes based on their folder names such as `about` and `profile` .

Routing Conventions :-
 - All routes must be placed inside the app folder.
 - Every file that corresponds to a route must be named page.js or page.tsx 
 - Every folder corresponds to a path segment in the browser URL.

 When these conventions are followed, the file automatically becomes available as a route.

 By creating a nested folder structure, files will automatically be routed in the same way within the URL. ( Refer to `blog` folder within the `NextJS/hello-world` project.)

 While this approach works for now, it's not always feasible to define routes using pre-defined paths espesically for 
 complex applications. We need dynamic routes in that case.

 In NextJS, we can enclose a folder name with brackets to create a dynamic route. (See `products` folder in NextJS/hello-world project)
 NextJS treats square brackets in a folder name as a dynamic segment enabling us to create dynamic routes.

NOTE :-  Every page in the app router receives route parameters as a prop.

When building complex application, it is common to encounter scenarios where multiple dynamic route segments are required.
For ex - /products/1 - is handled with dynamic routes.
But for handling - /products/1/reviews/1 - we need nested dynamic routes.

When dealing with multiple path segments, the solution lies in a nested folder structure.
It is possible to create nested dynamic routes by having dynamic segments in the folder names. (See `products` and `reviews` folder structures inside the `NextJS/hello-world` project)

`Catch all segments` route captures all URL segments and maps them to a single file in our project (i.e the `page.tsx` file in our `app/docs/[...slug]` folder)

This is particularly useful for documentation where we want different segments for better organisation & SEO, but the layout of the document remains the same. We define it once, but render it
for multiple variations of the URL.

NextJS Tutorial - 9 - From 6:50 mins,  (If we simply go to /docs, we get a 404. (which is taken care of by NextJS) )

However, if we wish to display the `<h1>Docs home page</h1>` in case of no slug, we've to make use of optional catchall segments.
All we've to do is wrap the square brackets with another pair of square brackets. ( i.e [[...slug]] in place of [..slug] )

Although NextJS provides routing conventions to follow, it remains flexible regarding how we structure our project files & folders.

FILE COLOCATION 
 - We already know that NextJS uses a file system based router where each folder represents a route segment mapped to a corresponding segment in the URL path.
   It's important to note that a route isn't publicly accessible until a `page.js` or `page.tsx` is added to the respective route segment.
 
 - Even when a route becomes publicly accessible, only the content returned by `page.tsx` is sent to the client. The content returned must be a 
   default exported React Component.


Private Folders :- 

 - A private folder indicates that it is a private implementation detail and should not be considered by the routing system.
 - This means that the folder & all its sub-folders are excluded from routing.

 - A private folder should be prefixed by an underscore. Within that folder, we can have utility functions.

 - Private folders can be helpful in few different scenarios : 
   : For separating UI logic from routing logic.
   : For consistently organizing internal files across a project.
   : For sorting and grouping files in code editors.
   : For avoiding potential naming conflicts with future NextJS file conventions.

 See _lib (It is a private folder, the component in it won't be rendered)
 
 On a side note, if you want to include an underscore in URL segments, we can prefix the folder name with "%5F" :- which is the URL-encoded form of an underscore.
 However, if you keep the encoded URL segment, it will be served. (for `_`, we can write `%5F`)

 Route Groups :- 
 - There's another feature that NextJS offers to help us organize our projects namely `Route Groups` .
 - This feature allows us to logically group our routes & project files without affecting the URL path structure.

 It is essential to organize routes & project files into groups based on sections or intent.
 - See `auth` folder in `hello-world` project (inside `src/app`). It is an example of Route group.
 - We can mark a folder as a route group to exclude it from the routes URL path.
   (example - earlier we had to write /auth/login. But after making `auth` as the route group by wrapping folder's name in parenthesis, we can simply write /login, /register and /forgot-password etc.)

 - Therefore, (auth) serves as a folder to help organize our code. However, we can have multiple levels of nested route groups if needed.


LAYOUTS :-
-----------

A page is UI that is unique to a route. A layout is UI that is shared between multiple pages in the app.

When building apps, it is common to have a consistent layout across different pages such as a header at the top and a footer at the bottom.
With the introduction of the layouts, achieving this becomes much easier in NextJS.

In nutshell, Layouts are UI components shared between multiple pages in an application.
And each app has a mandatory root layout which is the topmost layout.


How do we create Layouts ?
---------------------------

You can define a layout by default exporting a React component from a `layout.js` or `layout.tsx` file.
That component should accept a children prop that'll be populated with a child page during rendering.

The file `Layout.tsx` in the app folder (i.e in the `hello-world` project) serves as the topmost layout and is referred to as the 
root layout. The root layout is a mandatory layout for every NextJS application.

Every Layout component should accept a children prop that'll be replaced by a child component during rendering.
In `hello-world` project, the `page.tsx` in the app folder will replace the children prop when the layout is rendered in the browser.
The children prop here represents our `Home` component defined in `page.tsx` file.

Hence by defining a single `layout.tsx` file in the app folder, we can create a consistent layout for every page in our application.
 - For `localhost:3000`, the JSX for `page.tsx` within the app folder gets rendered.
 - When we do `localhost:3000/about`, the JSX for page.tsx in the about folder gets rendered.
 - Similarly, when we do `localhost:3000/profile`, the JSX for page.tsx in the profile folder gets rendered.

The Layout component renders the children prop for `page.tsx` to render a unique UI corresponding to the route.

It's important to note that Layouts can be nested. This approach of nested layouts allows us to create layouts that apply only to specific areas 
of our application. 

----------------------------------------------------------------------------------------------
**** IMP - Look at NextJS series Video 15 from 2:50 min to visualize nested layouts. ****
----------------------------------------------------------------------------------------------

Another Importance of a Route Group - Selectively apply a layout to certain segments while leaving others unchanged.
Route groups allow us to opt specific segments into a layout without altering the URL.

We've implemented the same - See `products` folders in the hello-world project -  we've `with-auth-layout` folder.

The routes outside of the group (i.e forgot-password) do not share the layout. Only `login` & `register` within the `with-auth-layout`
route group share this layout.

This is particularly useful in large projects with numerous layouts and route segments ensuring a tidy & organized project structure.

When it comes to building web applications, ensuring proper search engine optimization is crucial for increasing visibility and attracting users.

NextJS introduced the `Metadata API` which allows you to define metadata for each page ensuring accurate & relevant information is displayed when your pages are 
shared or indexed.

With the new App router, there are two methods to configure metadata in a `layout.tsx` OR a `page.tsx` file.
 1) Either export a static metadata object.
                   OR 
 2) Export a dynamic generateMetadata function.

Both `Layout` & `Page` can have metadata, but Page metadata takes precedence if both are present.

To enable client-side navigation, NextJS provides us with the `Link` component.

The `<Link>` component is a React component that extends the HTML `<a>` element, and it's the primary
way to navigate between routes in NextJS. To use it, we need to import it from "next/link".

In the <Link> component, `replace` prop replaces the current history state instead of adding a new URL to the stack.

************************************************************************
To determine if a link is active, NextJS provides `usePathname` hook.
************************************************************************

*******  Video 20 from 4:20 mins --> We won't see any changes reflecting for CSS if we do not have global CSS file deleted. As workaround, we'll have to create a styles.css file inside the (auth) folder. ***********

Read more over here --> https://nextjs.org/docs/pages/building-your-application/styling#adding-a-global-stylesheet


NextJS Tutorial NO 22 - Templates
-----------------------------------

From 2:08 mins, we've entered a value for the input element at the path /register.

Now when we navigate to `/login`, the input value remains as it is. 
Therefore, we can see that the state is preserved.

This is because Layouts only mount the part representing the content of the newly loaded page, but keep all the common elements untouched.
Layouts don't remount shared components resulting in better performance.

A majority of the time this is the behaviour we need. However, we might come across a scenario where we need the layouts to create a new instance
for each of their children on navigation. Example scenarios include `enter/exit animations` for Pages or running a side effect using the `useEffect` hook when the route changes.

For such situations, we can use the template file as replacement of the layout file. TEMPLATES are similar to layouts in that they wrap each child layout or page.

But, with templates, when a user navigates between routes that share a template, a new instance of the component is mounted, DOM elements are recreated, state is not preserved & effects 
are re-synchronized.

A template can be defined by exporting a default React component from a template.js or template.tsx file.
Similar to layouts, templates should also accept a children prop which will render the nested segments in the route.

So far, we've come across several special files --> page.tsx, layout.tsx, template.tsx, not-found.tsx 
Now, there's 1 more file called `loading.tsx`.

`loading.tsx` - This file allows us to create loading states that are displayed to users while a specific route segment's content is loading.
                The loading state appears immediately upon navigation, giving users the assurance that the application is responsive and actively loading content.

There's another vital part of our application namely error handling through a special file named `error.tsx`.

The component defined in `error.tsx` can also receive the error object as a prop to display more information.

Here's what `error.tsx` file does in the App router:- 
 - Automatically wrap a route segment and its nested children in a React error boundary
 - Create error UI tailored to specific segments using the file-system hierarchy to adjust granularity.
 - Isolate errors to affected segments while keeping the rest of the application functional.
 - Add functionality to attempt to recover from an error without a full page reload.


Tutorial 26 - Handling Errors in Nested Routes :-
----------------------------------------------------

From 1:20 min => When we hit `http://localhost:3000/products/1/reviews/1`,

The entire products route is replaced by the UI from the `error.tsx` file. The error from `page.tsx` in the [reviewId] folder bubbles to the nearest error 
boundary which is now defined in the `error.tsx` file in the `products` folder. Deeper the placement of `error.tsx`, more granular is error handling.

Usually, an `error.tsx` file will handle errors for all its nested child segments.

Let's say we have a component hierarchy as follows :- 

  <Layout>
    <Template>
     <ErrorBoundary fallback={ <Error /> }>
      <Suspense fallback={ <Loading /> }>
        <ErrorBoundary fallback={ <NotFound /> }>
           <Page />
        </ErrorBoundary>
      </Suspense>
     </ErrorBoundary> 
    </Template>
  </Layout>

Here, the error boundary does not catch errors thrown here because it's nested inside layout's component.


NextJS Video 27 (Handling errors in Layout) :-
------------------------------------------------

From 1:55 min, remember the error boundary will not handle errors thrown in a `layout.tsx` component within the same segment.
To navigate around this, we will need to place the `error.tsx` file in the layout's parent segment.
SO, we'll move `error.tsx` from `productId` folder into the products folder.


Now when we encounter the error on reloading the page, we observe that our app remains intact and the error boundary JSX renders in place of 
the products route. The header, footer and any other UI elements if present higher up in the tree are unaffected.

The placement of the `error.tsx` file plays a pivotal role in managing errors efficiently across different segments of our application.

Parallel Routes :- 
--------------------

Parallel routes are an advanced routing mechanism that allows for the simultaneous rendering of multiple pages within the same layout.

Parallel routes in Next.js are defined using a feature known as slots. Slots help structure our content in a modular fashion.
To define a slot, we use the `@folder` naming convention. Each slot is automatically then passed as a prop to its corresponding `layout.tsx` file component which 
we can then use to structure the dashboard page.

A clear benefits of parallel routes is their ability to split a single layout into various slots, making the code more manageable.

The true benefit of parallel routes lies in their capacity for independent route handling & sub-navigation.

Independent Route handling - One of the most compelling features. This means that each slot of our layout, such as user analytics or revenue metrics, can have its own 
loading and error states.
 > This granular control is particularly beneficial in scenarios where different sections of the page load at varying speeds or encounter unique errors.
 > For instance, if the user analytics data takes longer to load, we can display a loading spinner specifically for that section while other parts of the dashboard 
   remain interactive.

Sub-Navigation in routes - Offers a seamless subnavigation experience within each parallel route.

 > Each slot of our dashboard can essentially function as a mini-application, complete with its own navigation and state management.
 > This is espesically useful in a complex application such as our dashboard where different sections serve different purposes. 

 To summarize, Parallel Routes allow simultaneous rendering of different pages within the same layout. They are defined using slots. Slots organize content in a 
 modular fashion making code more manageable. They not only simplify code management but also enhance user experience with independent route handling & sub-navigation.

 Unmatched Routes :- 
 ---------------------

 Navigating from the UI - In the case of navigation within the UI, NextJS retains the previously active state of a slot regardless of changes in the URL.

 In NextJS Tutorial - Video 29, From 3:40 mins --> ,
 >  That means, when we navigate between `default notifications` (at /complex-dashboard) and archived notifications (at /complex-dashboard/archived) within the notification slot, 
    the other slots namely children, users & revenue remain unaffected.

 > These slots continue to display whatever content they were showing before and are not influenced by the shift in the URL path from `/complex-dashboard` to `/complex-dashboard/archived` or the reverse.

 > IN THE CASE OF A PAGE RELOAD, NextJS immediately searches for a `default.tsx` file within each unmatched slot.
 > The presence of this file is critical, as it provides the default content that Next.js will render in the user interface.

 > If this `default.tsx` file is missing in any of the unmatched slots for the current route, NextJS will render a 404 error.
   Without the `default.tsx` file, NextJS cannot determine the default content for these slots on the initial load.


DEFAULT.TSX file :- 
 - The `default.tsx` file in Next.js serves as a fallback to render content when the framework cannot retrieve a slot's active state from the current URL.
 

Intercepting Routes :-
------------------------

Intercepting routes allow us to intercept or stop the default routing behaviour to present an alternate view or component when navigating through the UI, while still 
preserving the intended route for scenarios like page reloads.

This can be useful if we want to show a route while keeping the context of the current page.

For instance, consider the scenario with the navigation bar.
> Clicking on a login link or a button normally takes you to a full login page. However, with intercepting routes we can configure the application to display a login modal instead, 
  while the URL is still updated to reflect the `/login` route. This ensures the link remains sharable. If the page is reloaded or someone accesses the page using the shared link, the full 
  login page is displayed as expected.

Idea behind intercepting routes :- Display a different UI while in the context of the current page, but render the regular UI on page reload.

To summarize, intercepting routes allow us to load a route from another part of our application within the current layout. This routing paradigm can be useful when we want to display the content
of a route without the user switching to a different context.